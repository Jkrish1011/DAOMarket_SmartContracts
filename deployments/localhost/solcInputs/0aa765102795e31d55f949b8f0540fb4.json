{
  "language": "Solidity",
  "sources": {
    "contracts/governance_standard/Registry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ERC1616.sol\";\n\ncontract Registry is ERC1616 {\n    enum Affiliation { CommodityValue }\n\n    // Top-level information about attribute types held in a static array.\n    uint256[1] private _attributeTypeIDs;\n\n    // Issued attributes held in a nested mapping by account & attribute type.\n    mapping(address => mapping(uint256 => bool)) private _issuedAttributes;\n\n    event SenderAddress(address senderAddr);\n\n    // Issued attribute values held in a nested mapping by account & type.\n    // uint256[2] = [PastValue, PresentValue]\n    mapping(address => mapping(uint256 => uint256[2]))\n        private _issuedAttributeValues;\n\n    constructor() {\n        _attributeTypeIDs = [0];\n    }\n\n    function addCommodityValue(uint256 value) external {\n        uint256 commodityValueValueIndex = uint256(Affiliation.CommodityValue);\n        // uint256 presentValueIndex = uint256(Affiliation.PresentValue);\n        \n        uint256 presentAttributeTypeID = _attributeTypeIDs[commodityValueValueIndex];\n\n        _issuedAttributes[msg.sender][presentAttributeTypeID] = true;\n\n        _issuedAttributeValues[msg.sender][presentAttributeTypeID] = [value, value];\n        emit SenderAddress(msg.sender);\n    }\n\n    function updateCommodityValue(uint256 newValue) external {\n        uint256 commodityValueValueIndex = uint256(Affiliation.CommodityValue);\n        // uint256 presentValueIndex = uint256(Affiliation.PresentValue);\n        \n        uint256 presentAttributeTypeID = _attributeTypeIDs[commodityValueValueIndex];\n\n        _issuedAttributes[msg.sender][presentAttributeTypeID] = true;\n        uint256 currentPresentValue = _issuedAttributeValues[msg.sender][presentAttributeTypeID][1];\n        _issuedAttributeValues[msg.sender][presentAttributeTypeID] = [currentPresentValue, newValue];\n    }\n\n    /**\n     * @notice Check if an attribute of the type with ID `attributeTypeID` has\n     * been assigned to the account at `account` and is currently valid.\n     * @param account address The account to check for a valid attribute.\n     * @param attributeTypeID uint256 The ID of the attribute type to check for.\n     * @return True if the attribute is assigned and valid, false otherwise.\n     * @dev This function MUST return either true or false - i.e. calling this\n     * function MUST NOT cause the caller to revert.\n     */\n    function hasAttribute(address account, uint256 attributeTypeID)\n        external\n        view\n        returns (bool)\n    {\n        // Return assignment status of attribute by account and attribute type ID\n        return _issuedAttributes[account][attributeTypeID];\n    }\n\n    /*\n     * @notice Retrieve the value of the attribute of the type with ID\n     * `attributeTypeID` on the account at `account`, assuming it is valid.\n     * @param account address The account to check for the given attribute value.\n     * @param attributeTypeID uint256 The ID of the attribute type to check for.\n     * @return The attribute value if the attribute is valid, reverts otherwise.\n     * @dev This function MUST revert if a directly preceding or subsequent\n     * function call to `hasAttribute` with identical `account` and\n     * `attributeTypeID` parameters would return false.\n     */\n    function getAttributeValue(address account, uint256 attributeTypeID)\n        external\n        view\n        returns (uint256[2] memory)\n    {\n        // Revert if attribute with given account & attribute type ID is unassigned\n        require(\n            _issuedAttributes[account][attributeTypeID],\n            \"Attribute type ID not found!\"\n        );\n        uint256[2] memory returnValue = _issuedAttributeValues[account][attributeTypeID];\n        return returnValue;\n    }\n\n    /**\n     * @notice Count the number of attribute types defined by the registry.\n     * @return The number of available attribute types.\n     * @dev This function MUST return a positive integer value  - i.e. calling\n     * this function MUST NOT cause the caller to revert.\n     */\n    function countAttributeTypes() external view returns (uint256) {\n        return _attributeTypeIDs.length;\n    }\n\n    /**\n     * @notice Get the ID of the attribute type at index `index`.\n     * @param index uint256 The index of the attribute type in question.\n     * @return The ID of the attribute type.\n     * @dev This function MUST revert if the provided `index` value falls outside\n     * of the range of the value returned from a directly preceding or subsequent\n     * function call to `countAttributeTypes`. It MUST NOT revert if the provided\n     * `index` value falls inside said range.\n     */\n    function getAttributeTypeID(uint256 index) external view returns (uint256) {\n        require(\n            index < _attributeTypeIDs.length,\n            \"Index Out of Bound!\"\n        );\n\n        return _attributeTypeIDs[index];\n    }\n}\n"
    },
    "contracts/interfaces/ERC1616.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-1616 Attribute Registry interface. ERC-165 ID: 0x5f46473f\n */\ninterface ERC1616 {\n    /**\n     * @notice Check if an attribute of the type with ID `attributeTypeID` has\n     * been assigned to the account at `account` and is currently valid.\n     * @param account address The account to check for a valid attribute.\n     * @param attributeTypeID uint256 The ID of the attribute type to check for.\n     * @return True if the attribute is assigned and valid, false otherwise.\n     * @dev This function MUST return either true or false - i.e. calling this\n     * function MUST NOT cause the caller to revert.\n     */\n    function hasAttribute(address account, uint256 attributeTypeID)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Retrieve the value of the attribute of the type with ID\n     * `attributeTypeID` on the account at `account`, assuming it is valid.\n     * @param account address The account to check for the given attribute value.\n     * @param attributeTypeID uint256 The ID of the attribute type to check for.\n     * @return The attribute value if the attribute is valid, reverts otherwise.\n     * @dev This function MUST revert if a directly preceding or subsequent\n     * function call to `hasAttribute` with identical `account` and\n     * `attributeTypeID` parameters would return false.\n     */\n    function getAttributeValue(address account, uint256 attributeTypeID)\n        external\n        view\n        returns (uint256[2] memory);\n\n    /**\n     * @notice Count the number of attribute types defined by the registry.\n     * @return The number of available attribute types.\n     * @dev This function MUST return a positive integer value  - i.e. calling\n     * this function MUST NOT cause the caller to revert.\n     */\n    function countAttributeTypes() external view returns (uint256);\n\n    /**\n     * @notice Get the ID of the attribute type at index `index`.\n     * @param index uint256 The index of the attribute type in question.\n     * @return The ID of the attribute type.\n     * @dev This function MUST revert if the provided `index` value falls outside\n     * of the range of the value returned from a directly preceding or subsequent\n     * function call to `countAttributeTypes`. It MUST NOT revert if the provided\n     * `index` value falls inside said range.\n     */\n    function getAttributeTypeID(uint256 index) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}